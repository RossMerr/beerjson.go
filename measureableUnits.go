// Code generated by jsonschema. DO NOT EDIT.
package beerjson

import "encoding/json"
import "fmt"

// ID: https://raw.githubusercontent.com/beerjson/beerjson/master/json/measureable_units.json

type AcidityType struct {
	Unit  AcidityUnitType `json:"unit", validate:"required"`
	Value float64         `json:"value", validate:"required"`
}

type AcidityUnitType string

func (s *AcidityUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = AcidityUnitType(v)

	switch *s {
	case AcidityUnitType_PH:
		return nil
	}
	return fmt.Errorf("AcidityUnitType: value '%v' does not match any value", v)
}

const (
	AcidityUnitType_PH AcidityUnitType = "pH"
)

type BitternessRangeType struct {
	Minimum BitternessType `json:"minimum", validate:"required"`
	Maximum BitternessType `json:"maximum", validate:"required"`
}

type BitternessType struct {
	Unit  BitternessUnitType `json:"unit", validate:"required"`
	Value float64            `json:"value", validate:"required"`
}

type BitternessUnitType string

func (s *BitternessUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = BitternessUnitType(v)

	switch *s {
	case BitternessUnitType_IBUs:
		return nil
	}
	return fmt.Errorf("BitternessUnitType: value '%v' does not match any value", v)
}

const (
	BitternessUnitType_IBUs BitternessUnitType = "IBUs"
)

type CarbonationRangeType struct {
	Minimum CarbonationType `json:"minimum", validate:"required"`
	Maximum CarbonationType `json:"maximum", validate:"required"`
}

type CarbonationType struct {
	Value float64             `json:"value", validate:"required"`
	Unit  CarbonationUnitType `json:"unit", validate:"required"`
}

type CarbonationUnitType string

func (s *CarbonationUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = CarbonationUnitType(v)

	switch *s {
	case CarbonationUnitType_Vols:
		return nil
	}
	return fmt.Errorf("CarbonationUnitType: value '%v' does not match any value", v)
}

const (
	CarbonationUnitType_Vols CarbonationUnitType = "vols"
)

type ColorRangeType struct {
	Minimum ColorType `json:"minimum", validate:"required"`
	Maximum ColorType `json:"maximum", validate:"required"`
}

// ColorType supports both grain color properties, such as Lovibond, and wort color properties such as SRM and EBC.
type ColorType struct {
	Unit  ColorUnitType `json:"unit", validate:"required"`
	Value float64       `json:"value", validate:"required"`
}

type ColorUnitType string

func (s *ColorUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = ColorUnitType(v)

	switch *s {
	case ColorUnitType_EBC:
		return nil
	case ColorUnitType_Lovi:
		return nil
	case ColorUnitType_SRM:
		return nil
	}
	return fmt.Errorf("ColorUnitType: value '%v' does not match any value", v)
}

const (
	ColorUnitType_EBC  ColorUnitType = "EBC"
	ColorUnitType_Lovi ColorUnitType = "Lovi"
	ColorUnitType_SRM  ColorUnitType = "SRM"
)

// Examples for concentration include ppm, ppb, and mg/l.
type ConcentrationType struct {
	Unit  ConcentrationUnitType `json:"unit", validate:"required"`
	Value float64               `json:"value", validate:"required"`
}

type ConcentrationUnitType string

func (s *ConcentrationUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = ConcentrationUnitType(v)

	switch *s {
	case ConcentrationUnitType_Ppm:
		return nil
	case ConcentrationUnitType_Ppb:
		return nil
	case ConcentrationUnitType_MgL:
		return nil
	}
	return fmt.Errorf("ConcentrationUnitType: value '%v' does not match any value", v)
}

const (
	ConcentrationUnitType_Ppm ConcentrationUnitType = "ppm"
	ConcentrationUnitType_Ppb ConcentrationUnitType = "ppb"
	ConcentrationUnitType_MgL ConcentrationUnitType = "mg/l"
)

type DateType string
type DensityUnitType string

func (s *DensityUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = DensityUnitType(v)

	switch *s {
	case DensityUnitType_Sg:
		return nil
	case DensityUnitType_Plato:
		return nil
	case DensityUnitType_Brix:
		return nil
	}
	return fmt.Errorf("DensityUnitType: value '%v' does not match any value", v)
}

const (
	DensityUnitType_Sg    DensityUnitType = "sg"
	DensityUnitType_Plato DensityUnitType = "plato"
	DensityUnitType_Brix  DensityUnitType = "brix"
)

// Diastatic power is a measurement of malted grains enzymatic content. A value of 35 Lintner is needed to self convert, while a value of 100 or more is desirable for base malts.
type DiastaticPowerType struct {
	Unit  DiastaticPowerUnitType `json:"unit", validate:"required"`
	Value float64                `json:"value", validate:"required"`
}

type DiastaticPowerUnitType string

func (s *DiastaticPowerUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = DiastaticPowerUnitType(v)

	switch *s {
	case DiastaticPowerUnitType_Lintner:
		return nil
	case DiastaticPowerUnitType_WK:
		return nil
	}
	return fmt.Errorf("DiastaticPowerUnitType: value '%v' does not match any value", v)
}

const (
	DiastaticPowerUnitType_Lintner DiastaticPowerUnitType = "Lintner"
	DiastaticPowerUnitType_WK      DiastaticPowerUnitType = "WK"
)

type GravityRangeType struct {
	Minimum GravityType `json:"minimum", validate:"required"`
	Maximum GravityType `json:"maximum", validate:"required"`
}

// Gravity refers to the both the measurements of percent of sugar content, ie plato and brix, as well as relative density ie specific gravity.
type GravityType struct {
	Unit  GravityUnitType `json:"unit", validate:"required"`
	Value float64         `json:"value", validate:"required"`
}

type GravityUnitType string

func (s *GravityUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = GravityUnitType(v)

	switch *s {
	case GravityUnitType_Sg:
		return nil
	case GravityUnitType_Plato:
		return nil
	case GravityUnitType_Brix:
		return nil
	}
	return fmt.Errorf("GravityUnitType: value '%v' does not match any value", v)
}

const (
	GravityUnitType_Sg    GravityUnitType = "sg"
	GravityUnitType_Plato GravityUnitType = "plato"
	GravityUnitType_Brix  GravityUnitType = "brix"
)

type MassType struct {
	Unit  MassUnitType `json:"unit", validate:"required"`
	Value float64      `json:"value", validate:"required"`
}

func (s *MassType) CultureAdditionTypeamount() {}

func (s *MassType) FermentableInventoryTypeamount() {}

func (s *MassType) FermentableAdditionTypeamount() {}

func (s *MassType) MiscellaneousAdditionTypeamount() {}

func (s *MassType) MiscellaneousInventoryTypeamount() {}

func (s *MassType) HopAdditionTypeamount() {}

func (s *MassType) HopInventoryTypeamount() {}

type MassUnitType string

func (s *MassUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = MassUnitType(v)

	switch *s {
	case MassUnitType_Mg:
		return nil
	case MassUnitType_G:
		return nil
	case MassUnitType_Kg:
		return nil
	case MassUnitType_Lb:
		return nil
	case MassUnitType_Oz:
		return nil
	}
	return fmt.Errorf("MassUnitType: value '%v' does not match any value", v)
}

const (
	MassUnitType_Mg MassUnitType = "mg"
	MassUnitType_G  MassUnitType = "g"
	MassUnitType_Kg MassUnitType = "kg"
	MassUnitType_Lb MassUnitType = "lb"
	MassUnitType_Oz MassUnitType = "oz"
)

type PercentRangeType struct {
	Minimum PercentType `json:"minimum", validate:"required"`
	Maximum PercentType `json:"maximum", validate:"required"`
}

type PercentType struct {
	Value float64         `json:"value", validate:"required"`
	Unit  PercentUnitType `json:"unit", validate:"required"`
}

type PercentUnitType string

func (s *PercentUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = PercentUnitType(v)

	switch *s {
	case PercentUnitType_No:
		return nil
	}
	return fmt.Errorf("PercentUnitType: value '%v' does not match any value", v)
}

const (
	PercentUnitType_No PercentUnitType = "%"
)

type PressureType struct {
	Unit  PressureUnitType `json:"unit", validate:"required"`
	Value float64          `json:"value", validate:"required"`
}

type PressureUnitType string

func (s *PressureUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = PressureUnitType(v)

	switch *s {
	case PressureUnitType_KPa:
		return nil
	case PressureUnitType_Psi:
		return nil
	case PressureUnitType_Bar:
		return nil
	}
	return fmt.Errorf("PressureUnitType: value '%v' does not match any value", v)
}

const (
	PressureUnitType_KPa PressureUnitType = "kPa"
	PressureUnitType_Psi PressureUnitType = "psi"
	PressureUnitType_Bar PressureUnitType = "bar"
)

type QualitativeRangeType string

func (s *QualitativeRangeType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = QualitativeRangeType(v)

	switch *s {
	case QualitativeRangeType_VeryLow:
		return nil
	case QualitativeRangeType_Low:
		return nil
	case QualitativeRangeType_MediumLow:
		return nil
	case QualitativeRangeType_Medium:
		return nil
	case QualitativeRangeType_MediumHigh:
		return nil
	case QualitativeRangeType_High:
		return nil
	case QualitativeRangeType_VeryHigh:
		return nil
	}
	return fmt.Errorf("QualitativeRangeType: value '%v' does not match any value", v)
}

const (
	QualitativeRangeType_VeryLow    QualitativeRangeType = "very low"
	QualitativeRangeType_Low        QualitativeRangeType = "low"
	QualitativeRangeType_MediumLow  QualitativeRangeType = "medium low"
	QualitativeRangeType_Medium     QualitativeRangeType = "medium"
	QualitativeRangeType_MediumHigh QualitativeRangeType = "medium high"
	QualitativeRangeType_High       QualitativeRangeType = "high"
	QualitativeRangeType_VeryHigh   QualitativeRangeType = "very high"
)

// Specific heat is the measurement of the amount of heat required to raise a given mass one degree..
type SpecificHeatType struct {
	Unit  SpecificHeatUnitType `json:"unit", validate:"required"`
	Value float64              `json:"value", validate:"required"`
}

type SpecificHeatUnitType string

func (s *SpecificHeatUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = SpecificHeatUnitType(v)

	switch *s {
	case SpecificHeatUnitType_CalGC:
		return nil
	case SpecificHeatUnitType_JKgK:
		return nil
	case SpecificHeatUnitType_BTULbF:
		return nil
	}
	return fmt.Errorf("SpecificHeatUnitType: value '%v' does not match any value", v)
}

const (
	SpecificHeatUnitType_CalGC  SpecificHeatUnitType = "Cal/(g C)"
	SpecificHeatUnitType_JKgK   SpecificHeatUnitType = "J/(kg K)"
	SpecificHeatUnitType_BTULbF SpecificHeatUnitType = "BTU/(lb F)"
)

// Specific volume is the inverse of density, with units of volume over mass, ie qt/lb or L/kg. Commonly used for mash thickness.
type SpecificVolumeType struct {
	Value float64                `json:"value", validate:"required"`
	Unit  SpecificVolumeUnitType `json:"unit", validate:"required"`
}

type SpecificVolumeUnitType string

func (s *SpecificVolumeUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = SpecificVolumeUnitType(v)

	switch *s {
	case SpecificVolumeUnitType_QtLb:
		return nil
	case SpecificVolumeUnitType_GalLb:
		return nil
	case SpecificVolumeUnitType_GalOz:
		return nil
	case SpecificVolumeUnitType_LG:
		return nil
	case SpecificVolumeUnitType_LKg:
		return nil
	case SpecificVolumeUnitType_FlozOz:
		return nil
	case SpecificVolumeUnitType_M3Kg:
		return nil
	case SpecificVolumeUnitType_Ft3Lb:
		return nil
	}
	return fmt.Errorf("SpecificVolumeUnitType: value '%v' does not match any value", v)
}

const (
	SpecificVolumeUnitType_QtLb   SpecificVolumeUnitType = "qt/lb"
	SpecificVolumeUnitType_GalLb  SpecificVolumeUnitType = "gal/lb"
	SpecificVolumeUnitType_GalOz  SpecificVolumeUnitType = "gal/oz"
	SpecificVolumeUnitType_LG     SpecificVolumeUnitType = "l/g"
	SpecificVolumeUnitType_LKg    SpecificVolumeUnitType = "l/kg"
	SpecificVolumeUnitType_FlozOz SpecificVolumeUnitType = "floz/oz"
	SpecificVolumeUnitType_M3Kg   SpecificVolumeUnitType = "m^3/kg"
	SpecificVolumeUnitType_Ft3Lb  SpecificVolumeUnitType = "ft^3/lb"
)

type TemperatureRangeType struct {
	Minimum TemperatureType `json:"minimum", validate:"required"`
	Maximum TemperatureType `json:"maximum", validate:"required"`
}

type TemperatureType struct {
	Unit  TemperatureUnitType `json:"unit", validate:"required"`
	Value float64             `json:"value", validate:"required"`
}

type TemperatureUnitType string

func (s *TemperatureUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = TemperatureUnitType(v)

	switch *s {
	case TemperatureUnitType_C:
		return nil
	case TemperatureUnitType_F:
		return nil
	}
	return fmt.Errorf("TemperatureUnitType: value '%v' does not match any value", v)
}

const (
	TemperatureUnitType_C TemperatureUnitType = "C"
	TemperatureUnitType_F TemperatureUnitType = "F"
)

type TimeType struct {
	Unit  TimeUnitType `json:"unit", validate:"required"`
	Value float64      `json:"value", validate:"required"`
}

type TimeUnitType string

func (s *TimeUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = TimeUnitType(v)

	switch *s {
	case TimeUnitType_Sec:
		return nil
	case TimeUnitType_Min:
		return nil
	case TimeUnitType_Hr:
		return nil
	case TimeUnitType_Day:
		return nil
	case TimeUnitType_Week:
		return nil
	case TimeUnitType_Month:
		return nil
	case TimeUnitType_Year:
		return nil
	}
	return fmt.Errorf("TimeUnitType: value '%v' does not match any value", v)
}

const (
	TimeUnitType_Sec   TimeUnitType = "sec"
	TimeUnitType_Min   TimeUnitType = "min"
	TimeUnitType_Hr    TimeUnitType = "hr"
	TimeUnitType_Day   TimeUnitType = "day"
	TimeUnitType_Week  TimeUnitType = "week"
	TimeUnitType_Month TimeUnitType = "month"
	TimeUnitType_Year  TimeUnitType = "year"
)

// UnitType is used where unitless amounts are required, such as 1 apple, or 1 yeast packet.
type UnitType struct {
	Unit  UnitUnitType `json:"unit", validate:"required"`
	Value float64      `json:"value", validate:"required"`
}

func (s *UnitType) CultureAdditionTypeamount() {}

func (s *UnitType) MiscellaneousAdditionTypeamount() {}

func (s *UnitType) MiscellaneousInventoryTypeamount() {}

type UnitUnitType string

func (s *UnitUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = UnitUnitType(v)

	switch *s {
	case UnitUnitType_No1:
		return nil
	case UnitUnitType_Unit:
		return nil
	case UnitUnitType_Each:
		return nil
	case UnitUnitType_Dimensionless:
		return nil
	case UnitUnitType_Pkg:
		return nil
	}
	return fmt.Errorf("UnitUnitType: value '%v' does not match any value", v)
}

const (
	UnitUnitType_No1           UnitUnitType = "1"
	UnitUnitType_Unit          UnitUnitType = "unit"
	UnitUnitType_Each          UnitUnitType = "each"
	UnitUnitType_Dimensionless UnitUnitType = "dimensionless"
	UnitUnitType_Pkg           UnitUnitType = "pkg"
)

type VersionType float64
type VolumeType struct {
	Unit  VolumeUnitType `json:"unit", validate:"required"`
	Value float64        `json:"value", validate:"required"`
}

func (s *VolumeType) CultureAdditionTypeamount() {}

func (s *VolumeType) FermentableInventoryTypeamount() {}

func (s *VolumeType) FermentableAdditionTypeamount() {}

func (s *VolumeType) MiscellaneousAdditionTypeamount() {}

func (s *VolumeType) MiscellaneousInventoryTypeamount() {}

func (s *VolumeType) HopAdditionTypeamount() {}

func (s *VolumeType) HopInventoryTypeamount() {}

type VolumeUnitType string

func (s *VolumeUnitType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = VolumeUnitType(v)

	switch *s {
	case VolumeUnitType_Ml:
		return nil
	case VolumeUnitType_L:
		return nil
	case VolumeUnitType_Tsp:
		return nil
	case VolumeUnitType_Tbsp:
		return nil
	case VolumeUnitType_Floz:
		return nil
	case VolumeUnitType_Cup:
		return nil
	case VolumeUnitType_Pt:
		return nil
	case VolumeUnitType_Qt:
		return nil
	case VolumeUnitType_Gal:
		return nil
	case VolumeUnitType_Bbl:
		return nil
	case VolumeUnitType_Ifloz:
		return nil
	case VolumeUnitType_Ipt:
		return nil
	case VolumeUnitType_Iqt:
		return nil
	case VolumeUnitType_Igal:
		return nil
	case VolumeUnitType_Ibbl:
		return nil
	}
	return fmt.Errorf("VolumeUnitType: value '%v' does not match any value", v)
}

const (
	VolumeUnitType_Ml    VolumeUnitType = "ml"
	VolumeUnitType_L     VolumeUnitType = "l"
	VolumeUnitType_Tsp   VolumeUnitType = "tsp"
	VolumeUnitType_Tbsp  VolumeUnitType = "tbsp"
	VolumeUnitType_Floz  VolumeUnitType = "floz"
	VolumeUnitType_Cup   VolumeUnitType = "cup"
	VolumeUnitType_Pt    VolumeUnitType = "pt"
	VolumeUnitType_Qt    VolumeUnitType = "qt"
	VolumeUnitType_Gal   VolumeUnitType = "gal"
	VolumeUnitType_Bbl   VolumeUnitType = "bbl"
	VolumeUnitType_Ifloz VolumeUnitType = "ifloz"
	VolumeUnitType_Ipt   VolumeUnitType = "ipt"
	VolumeUnitType_Iqt   VolumeUnitType = "iqt"
	VolumeUnitType_Igal  VolumeUnitType = "igal"
	VolumeUnitType_Ibbl  VolumeUnitType = "ibbl"
)
