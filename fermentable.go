// Code generated by jsonschema. DO NOT EDIT.
package beerjson

import "encoding/json"
import "fmt"

// ID: https://raw.githubusercontent.com/beerjson/beerjson/master/json/fermentable.json

// FermentableAdditionType collects the attributes of each fermentable ingredient for use in a recipe fermentable bill.
type FermentableAdditionType struct {
	Producer *string    `json:"producer,omitempty"`
	Color    *ColorType `json:"color,omitempty"`
	Name     *string    `json:"name,omitempty"`
	Origin   *string    `json:"origin,omitempty"`
	// The timing object fully describes the timing of an addition with options for basis on time, gravity, or pH at any process step.
	Timing                    *TimingType                   `json:"timing,omitempty"`
	Amount                    FermentableAdditionTypeAmount `json:"amount", validate:"required,oneof"`
	ProductId                 *string                       `json:"product_id,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup    `json:"grain_group,omitempty"`
	Yield                     *YieldType                    `json:"yield,omitempty"`
	FermentableBaseType       *FermentableBaseType          `json:"type,omitempty"`
}

func (s *FermentableAdditionType) UnmarshalJSON(b []byte) error {
	m := map[string]json.RawMessage{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}

	fermentableAdditionTypeAmount := func() FermentableAdditionTypeAmount {
		raw, ok := m["amount"]
		if !ok {
			return nil
		}

		var volumeType VolumeType
		if err := json.Unmarshal(raw, &volumeType); err == nil {
			return &volumeType
		}

		var massType MassType
		if err := json.Unmarshal(raw, &massType); err == nil {
			return &massType
		}

		return nil
	}
	type Alias FermentableAdditionType
	aux := &struct {
		Amount FermentableAdditionTypeAmount `json:"amount", validate:"required,oneof"`
		*Alias
	}{
		Amount: fermentableAdditionTypeAmount(),
		Alias:  (*Alias)(s),
	}

	if err := json.Unmarshal(b, &aux); err != nil {
		return err
	}

	s.Amount = aux.Amount

	return nil
}

// FermentableAdditionTypeAmount
type FermentableAdditionTypeAmount interface {
	FermentableAdditionTypeamount()
}

// FermentableBase provides unique properties to identify individual records of fermentable ingredients.
type FermentableBase struct {
	FermentableBaseType       FermentableBaseType        `json:"type", validate:"required"`
	Origin                    *string                    `json:"origin,omitempty"`
	Producer                  *string                    `json:"producer,omitempty"`
	ProductId                 *string                    `json:"product_id,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup `json:"grain_group,omitempty"`
	Yield                     YieldType                  `json:"yield", validate:"required"`
	Color                     ColorType                  `json:"color", validate:"required"`
	Name                      string                     `json:"name", validate:"required"`
}

type FermentableBaseGrainGroup string

func (s *FermentableBaseGrainGroup) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = FermentableBaseGrainGroup(v)

	switch *s {
	case FermentableBaseGrainGroup_Base:
		return nil
	case FermentableBaseGrainGroup_Caramel:
		return nil
	case FermentableBaseGrainGroup_Flaked:
		return nil
	case FermentableBaseGrainGroup_Roasted:
		return nil
	case FermentableBaseGrainGroup_Specialty:
		return nil
	case FermentableBaseGrainGroup_Smoked:
		return nil
	case FermentableBaseGrainGroup_Adjunct:
		return nil
	}
	return fmt.Errorf("FermentableBaseGrainGroup: value '%v' does not match any value", v)
}

const (
	FermentableBaseGrainGroup_Base      FermentableBaseGrainGroup = "base"
	FermentableBaseGrainGroup_Caramel   FermentableBaseGrainGroup = "caramel"
	FermentableBaseGrainGroup_Flaked    FermentableBaseGrainGroup = "flaked"
	FermentableBaseGrainGroup_Roasted   FermentableBaseGrainGroup = "roasted"
	FermentableBaseGrainGroup_Specialty FermentableBaseGrainGroup = "specialty"
	FermentableBaseGrainGroup_Smoked    FermentableBaseGrainGroup = "smoked"
	FermentableBaseGrainGroup_Adjunct   FermentableBaseGrainGroup = "adjunct"
)

type FermentableBaseType string

func (s *FermentableBaseType) UnmarshalJSON(b []byte) error {
	var v string
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	*s = FermentableBaseType(v)

	switch *s {
	case FermentableBaseType_DryExtract:
		return nil
	case FermentableBaseType_Extract:
		return nil
	case FermentableBaseType_Grain:
		return nil
	case FermentableBaseType_Sugar:
		return nil
	case FermentableBaseType_Fruit:
		return nil
	case FermentableBaseType_Juice:
		return nil
	case FermentableBaseType_Honey:
		return nil
	case FermentableBaseType_Other:
		return nil
	}
	return fmt.Errorf("FermentableBaseType: value '%v' does not match any value", v)
}

const (
	FermentableBaseType_DryExtract FermentableBaseType = "dry extract"
	FermentableBaseType_Extract    FermentableBaseType = "extract"
	FermentableBaseType_Grain      FermentableBaseType = "grain"
	FermentableBaseType_Sugar      FermentableBaseType = "sugar"
	FermentableBaseType_Fruit      FermentableBaseType = "fruit"
	FermentableBaseType_Juice      FermentableBaseType = "juice"
	FermentableBaseType_Honey      FermentableBaseType = "honey"
	FermentableBaseType_Other      FermentableBaseType = "other"
)

type FermentableInventoryType struct {
	Amount FermentableInventoryTypeAmount `json:"amount,omitempty", validate:"oneof"`
}

func (s *FermentableInventoryType) UnmarshalJSON(b []byte) error {
	m := map[string]json.RawMessage{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}

	fermentableInventoryTypeAmount := func() FermentableInventoryTypeAmount {
		raw, ok := m["amount"]
		if !ok {
			return nil
		}

		var volumeType VolumeType
		if err := json.Unmarshal(raw, &volumeType); err == nil {
			return &volumeType
		}

		var massType MassType
		if err := json.Unmarshal(raw, &massType); err == nil {
			return &massType
		}

		return nil
	}
	type Alias FermentableInventoryType
	aux := &struct {
		Amount FermentableInventoryTypeAmount `json:"amount,omitempty", validate:"oneof"`
		*Alias
	}{
		Amount: fermentableInventoryTypeAmount(),
		Alias:  (*Alias)(s),
	}

	if err := json.Unmarshal(b, &aux); err != nil {
		return err
	}

	s.Amount = aux.Amount

	return nil
}

// FermentableInventoryTypeAmount
type FermentableInventoryTypeAmount interface {
	FermentableInventoryTypeamount()
}

// FermentableType collects the attributes of a fermentable ingredient to store as record information.
type FermentableType struct {
	// The percentage of protein. Higher values may indicate a possibility of haze, or lautering issues.
	Protein *PercentType `json:"protein,omitempty"`
	// True if the fermentable must be mashed, false if it can be steeped.
	RecommendMash *bool        `json:"recommend_mash,omitempty"`
	Name          *string      `json:"name,omitempty"`
	Origin        *string      `json:"origin,omitempty"`
	Producer      *string      `json:"producer,omitempty"`
	Moisture      *PercentType `json:"moisture,omitempty"`
	// The recommended maximum percentage to use in a grain bill.
	MaxInBatch *PercentType `json:"max_in_batch,omitempty"`
	Color      *ColorType   `json:"color,omitempty"`
	// The Kolbach Index, also known as soluble to total ratio of nitrogen or protein, is used to indcate the degree of malt modification. A value above 35% is desired for simple single infusion mashing, undermodified malt may require multiple step mashes or decoction.
	KolbachIndex *float64 `json:"kolbach_index,omitempty"`
	// Diastatic power is a measurement of malted grains enzymatic content. A value of 35 Lintner is needed to self convert, while a value of 100 or more is desirable.
	DiastaticPower            *DiastaticPowerType        `json:"diastatic_power,omitempty"`
	FermentableBaseType       *FermentableBaseType       `json:"type,omitempty"`
	ProductId                 *string                    `json:"product_id,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup `json:"grain_group,omitempty"`
	Yield                     *YieldType                 `json:"yield,omitempty"`
	// Where diastatic power gives the total amount of all enzymes, alpha amylase, also known as dextrinizing units, refers to only the total amount of alpa amylase in the malted grain. A value of 25-50 is desirable for base malt.
	AlphaAmylase *float64                  `json:"alpha_amylase,omitempty"`
	Inventory    *FermentableInventoryType `json:"inventory,omitempty"`
	Notes        *string                   `json:"notes,omitempty"`
	// Used to indicate the ‘crystallized’ percentage of starches for crystal malts.
	Glassy *PercentType `json:"glassy,omitempty"`
	// The percentage of grain that masses through sieves with gaps of 7/64 and 6/64, desired values of 80% or higher which indicate plump kernels.
	Plump *PercentType `json:"plump,omitempty"`
	Half  *PercentType `json:"half,omitempty"`
	// The opposite of glassy, a mealy kernel is one that is not glassy. Base malt should be at least 90%, single step mashes generally require 95% or higher.
	Mealy *PercentType `json:"mealy,omitempty"`
	// The Percentage of grain that makes it through a thin mesh screen, typically 5/64 inch. Values less than 3% are desired.
	Thru *PercentType `json:"thru,omitempty"`
	// Friability is the measure of a malts ability to crumble during the crush, and is used as an indicator for easy gelatinization of the grain and starches, as well as modification of the malt. Value of 85% of higher indicates a well modified malt and is suitable for single step mashes. Lower values may require a step mash.
	Friability *PercentType `json:"friability,omitempty"`
	// The pH of the resultant wort for 1 lb of grain mashed in 1 gallon of distilled water. Used in many water chemistry / mash pH prediction software.
	DipH *AcidityType `json:"di_ph,omitempty"`
	// The measure of wort viscosity, typically associated with the breakdown of beta-glucans. The higher the viscosity, the greater the need for a glucan rest and the less suitable for a fly sparge.
	Viscosity *ViscosityType `json:"viscosity,omitempty"`
	// The amount of DMS precursors, namely S-methyl methionine (SMM) and dimethyl sulfoxide (DMSO) in the malt which convert to dimethyl sulfide (DMS).
	DMSP *ConcentrationType `json:"dms_p,omitempty"`
	// Free Amino Nitrogen (FAN) is a critical yeast nutrient. Typical values for base malt is 170.
	FAN *ConcentrationType `json:"fan,omitempty"`
	// Fermentability - Used in Extracts to indicate a baseline typical apparent attenuation for a typical medium attenuation yeast.
	Fermentability *PercentType `json:"fermentability,omitempty"`
	// Values of 180 or more may suggest a glucan rest and avoiding fly sparging.
	BetaGlucan *ConcentrationType `json:"beta_glucan,omitempty"`
}

// The potential yield of the fermentable ingredient, supporting SG, or percentage. eg 1.037 or 80% are valid yield types.
type YieldType struct {
	// Percentage yield compared to succrose of a fine grind. eg 80%
	FineGrind *PercentType `json:"fine_grind,omitempty"`
	// Percentage yield compared to succrose of a coarse grind. eg 78%
	CoarseGrind *PercentType `json:"coarse_grind,omitempty"`
	// The difference between fine and coarse grind, a difference more than 2 percent can indicate a protein or step mash may be desirable. eg 2%.
	FineCoarseDifference *PercentType `json:"fine_coarse_difference,omitempty"`
	// The potential yield of the fermentable ingredient for 1 lb of grain mashed in 1 gallon of water. eg 1.037
	Potential *GravityType `json:"potential,omitempty"`
}
