// Code generated by jsonschema. DO NOT EDIT.
package beerjson

import "encoding/json"

// ID: https://raw.githubusercontent.com/beerjson/beerjson/master/json/fermentable.json

// FermentableAdditionType collects the attributes of each fermentable ingredient for use in a recipe fermentable bill.
type FermentableAdditionType struct {
	FermentableBaseType       *FermentableBaseType          `json:"type,omitempty"`
	Origin                    *string                       `json:"origin,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup    `json:"grain_group,omitempty"`
	Amount                    FermentableAdditionTypeAmount `json:"amount", validate:"oneof,required"`
	Yield                     *YieldType                    `json:"yield,omitempty"`
	Color                     *ColorType                    `json:"color,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	Producer                  *string                       `json:"producer,omitempty"`
	ProductId                 *string                       `json:"product_id,omitempty"`
	// The timing object fully describes the timing of an addition with options for basis on time, gravity, or pH at any process step.
	Timing *TimingType `json:"timing,omitempty"`
}

func (s *FermentableAdditionType) UnmarshalJSON(b []byte) error {
	m := map[string]json.RawMessage{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}

	fermentableAdditionTypeAmount := func() FermentableAdditionTypeAmount {
		raw, ok := m["amount"]
		if !ok {
			return nil
		}

		var volumeType VolumeType
		if err := json.Unmarshal(raw, &volumeType); err == nil {
			return &volumeType
		}

		var massType MassType
		if err := json.Unmarshal(raw, &massType); err == nil {
			return &massType
		}

		return nil
	}
	type Alias FermentableAdditionType
	aux := &struct {
		Amount FermentableAdditionTypeAmount `json:"amount", validate:"oneof,required"`
		*Alias
	}{
		Amount: fermentableAdditionTypeAmount(),
		Alias:  (*Alias)(s),
	}

	if err := json.Unmarshal(b, &aux); err != nil {
		return err
	}

	s.Amount = aux.Amount

	return nil
}

// FermentableAdditionTypeAmount
type FermentableAdditionTypeAmount interface {
	FermentableAdditionTypeamount()
}

// FermentableBase provides unique properties to identify individual records of fermentable ingredients.
type FermentableBase struct {
	ProductId                 *string                    `json:"product_id,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup `json:"grain_group,omitempty"`
	Yield                     YieldType                  `json:"yield", validate:"required"`
	Color                     ColorType                  `json:"color", validate:"required"`
	Name                      string                     `json:"name", validate:"required"`
	FermentableBaseType       FermentableBaseType        `json:"type", validate:"required"`
	Origin                    *string                    `json:"origin,omitempty"`
	Producer                  *string                    `json:"producer,omitempty"`
}

type FermentableBaseGrainGroup string

const (
	FermentableBaseGrainGroup_Base      FermentableBaseGrainGroup = "base"
	FermentableBaseGrainGroup_Caramel   FermentableBaseGrainGroup = "caramel"
	FermentableBaseGrainGroup_Flaked    FermentableBaseGrainGroup = "flaked"
	FermentableBaseGrainGroup_Roasted   FermentableBaseGrainGroup = "roasted"
	FermentableBaseGrainGroup_Specialty FermentableBaseGrainGroup = "specialty"
	FermentableBaseGrainGroup_Smoked    FermentableBaseGrainGroup = "smoked"
	FermentableBaseGrainGroup_Adjunct   FermentableBaseGrainGroup = "adjunct"
)

type FermentableBaseType string

const (
	FermentableBaseType_DryExtract FermentableBaseType = "dry extract"
	FermentableBaseType_Extract    FermentableBaseType = "extract"
	FermentableBaseType_Grain      FermentableBaseType = "grain"
	FermentableBaseType_Sugar      FermentableBaseType = "sugar"
	FermentableBaseType_Fruit      FermentableBaseType = "fruit"
	FermentableBaseType_Juice      FermentableBaseType = "juice"
	FermentableBaseType_Honey      FermentableBaseType = "honey"
	FermentableBaseType_Other      FermentableBaseType = "other"
)

type FermentableInventoryType struct {
	Amount FermentableInventoryTypeAmount `json:"amount,omitempty", validate:"oneof"`
}

func (s *FermentableInventoryType) UnmarshalJSON(b []byte) error {
	m := map[string]json.RawMessage{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}

	fermentableInventoryTypeAmount := func() FermentableInventoryTypeAmount {
		raw, ok := m["amount"]
		if !ok {
			return nil
		}

		var volumeType VolumeType
		if err := json.Unmarshal(raw, &volumeType); err == nil {
			return &volumeType
		}

		var massType MassType
		if err := json.Unmarshal(raw, &massType); err == nil {
			return &massType
		}

		return nil
	}
	type Alias FermentableInventoryType
	aux := &struct {
		Amount FermentableInventoryTypeAmount `json:"amount,omitempty", validate:"oneof"`
		*Alias
	}{
		Amount: fermentableInventoryTypeAmount(),
		Alias:  (*Alias)(s),
	}

	if err := json.Unmarshal(b, &aux); err != nil {
		return err
	}

	s.Amount = aux.Amount

	return nil
}

// FermentableInventoryTypeAmount
type FermentableInventoryTypeAmount interface {
	FermentableInventoryTypeamount()
}

// FermentableType collects the attributes of a fermentable ingredient to store as record information.
type FermentableType struct {
	// The recommended maximum percentage to use in a grain bill.
	MaxInBatch *PercentType `json:"max_in_batch,omitempty"`
	// True if the fermentable must be mashed, false if it can be steeped.
	RecommendMash *bool `json:"recommend_mash,omitempty"`
	// The percentage of protein. Higher values may indicate a possibility of haze, or lautering issues.
	Protein                   *PercentType               `json:"protein,omitempty"`
	ProductId                 *string                    `json:"product_id,omitempty"`
	FermentableBaseGrainGroup *FermentableBaseGrainGroup `json:"grain_group,omitempty"`
	Yield                     *YieldType                 `json:"yield,omitempty"`
	FermentableBaseType       *FermentableBaseType       `json:"type,omitempty"`
	Producer                  *string                    `json:"producer,omitempty"`
	// Where diastatic power gives the total amount of all enzymes, alpha amylase, also known as dextrinizing units, refers to only the total amount of alpa amylase in the malted grain. A value of 25-50 is desirable for base malt.
	AlphaAmylase *float64   `json:"alpha_amylase,omitempty"`
	Color        *ColorType `json:"color,omitempty"`
	Name         *string    `json:"name,omitempty"`
	// Diastatic power is a measurement of malted grains enzymatic content. A value of 35 Lintner is needed to self convert, while a value of 100 or more is desirable.
	DiastaticPower *DiastaticPowerType       `json:"diastatic_power,omitempty"`
	Moisture       *PercentType              `json:"moisture,omitempty"`
	Origin         *string                   `json:"origin,omitempty"`
	Inventory      *FermentableInventoryType `json:"inventory,omitempty"`
	// The Kolbach Index, also known as soluble to total ratio of nitrogen or protein, is used to indcate the degree of malt modification. A value above 35% is desired for simple single infusion mashing, undermodified malt may require multiple step mashes or decoction.
	KolbachIndex *float64 `json:"kolbach_index,omitempty"`
	Notes        *string  `json:"notes,omitempty"`
}

// The potential yield of the fermentable ingredient, supporting SG, or percentage. eg 1.037 or 80% are valid yield types.
type YieldType struct {
	// Percentage yield compared to succrose of a fine grind. eg 80%
	FineGrind *PercentType `json:"fine_grind,omitempty"`
	// Percentage yield compared to succrose of a coarse grind. eg 78%
	CoarseGrind *PercentType `json:"coarse_grind,omitempty"`
	// The difference between fine and coarse grind, a difference more than 2 percent can indicate a protein or step mash may be desirable. eg 2%.
	FineCoarseDifference *PercentType `json:"fine_coarse_difference,omitempty"`
	// The potential yield of the fermentable ingredient for 1 lb of grain mashed in 1 gallon of water. eg 1.037
	Potential *GravityType `json:"potential,omitempty"`
}
